#!/bin/bash

DEFAULT_EXCLUDE_FILE='dump.exclude'
DEFAULT_PATHES=(
  '/dev/block/*/*/by-name'
  '/dev/block/*/*/*/by-name'
  '/dev/block/*/*/by-num'
  '/dev/block/*/*/*/by-num'
)
DEFAULT_PARTITION_FOR_TESTMODE='boot'
DEFAULT_REMOTE_WORKDIR_FOR_TESTMODE='/data/local/tmp'

progname=`basename $0` || progname="$0"
usage="$progname [-lvnt] [-p GLOB] [-s SERIAL] [-x EXCLUDE] [-w WORKDIR] {-a|PARTITION ...}
$progname -l {-a|PARTITION ...}
$progname -h
  -a
    dump all partitions except those designated with -x option
  -D
    echoing debugging messages
  -l
    list partition names on a device and exit
  -p GLOB
    A shell glob pattern to search directories that includes partition names as file(node) names
    example: $progname -p /dev/block/platform/*/msm_sdcc.1/by-name
    To use multiple globs, you can repeat -p options.
    default: ${DEFAULT_PATHES[@]}
  -s SERIAL
    use device with given serial number (overrides \$ANDROID_SERIAL), same as adb command
  -t
    TEST mode.
    Get dumped images by both a traditional dd method and a cat method ($progname is normailly used this),
    and compare both images by cmp command. If two images differ, perhaps the cat method is buggy.
  -w WORKDIR
    a working directory path on a remote adb device, used only on TEST mode.
    default: $DEFAULT_REMOTE_WORKDIR_FOR_TESTMODE
  -x EXCLUDE
    A file includes partition names to be excluded from dumping
    default: $DEFAULT_EXCLUDE_FILE
  -h
    print this message and exit
  -v
    verbosely echoing information messages (verbosity level 1)
  -v -v
    verbosely echoing information messages (verbosity level 2)
  -n
    dry-run (implies single -v)
  PARTITION
    a partition name to be dumped. shell globbing available
"

tmpfile=
cleanup=
verbose1=false
verbose2=false
dryrun=false
listp=false
testmodep=false
allp=false
debug=false
excludefile="$DEFAULT_EXCLUDE_FILE"
workdir="$DEFAULT_REMOTE_WORKDIR_FOR_TESTMODE"
globs=()
while true; do
  case "$1" in
  -a) allp=true; shift;;
  -D) debug=true; shift;;
  -l) listp=true; shift;;
  -p) globs+=("$2"); shift 2;;
  -s) serial="$2"; shift 2;;
  -t) testmodep=true; shift;;
  -w) workdir="$2"; shift 2;;
  -x) excludefile="$2"; shift 2;;
  -h) echo "$usage"; exit 0;;
  -n) dryrun=true; $verbose1 && verbose2=true; verbose1=true; shift;;
  -v) $verbose1 && verbose2=true; verbose1=true; shift;;
  -*) shift;;
  *) break;;
  esac
done
test ${#globs[@]} -eq 0 && globs=${DEFAULT_PATHES[@]}

## functions
##

list_adb_devices() {
  adb devices | grep -v -e '^List of devices attached$' -e '^$'
}

number_of_adb_devices() {
  list_adb_devices | if [ -n "$serial" ]; then grep "^$serial"; else cat -; fi | wc -l
}

_adb() {
  $debug && echo debug: adb ${serial:+-s $serial} "$@">&2
  $debug && set -x
  adb ${serial:+-s $serial} "$@"
  $debug && set +x
}

adb_shell() {
  _adb shell "$@" | sed -b 's/\r$//'
}

adb_echo_result() {
  adb_shell "$@" ">/dev/null" "2>/dev/null" ";" "echo" "\$?"
}

adb_return_result() {
  rc=`adb_echo_result "$@"`
  return $rc
}

remote_cmd_not_exist() {
  rc=`adb_echo_result "$@"`
  test "$rc" = "127"
}

globmatch() {
  case "$1" in
  $2) true;;
  *) false;;
  esac
}

remote_adb_is_rooted() {
  globmatch "`adb_shell id`" 'uid=0\(*'
}

remote_su_not_exist() {
  remote_cmd_not_exist su -c echo
}

_run() {
  $verbose1 && echo "$@">&2
  $dryrun || eval "$@"
}

get_partitions_list_dir() {
  declare -n partListGlobs=$1
  partListDir=
  for glob in ${partListGlobs[@]}; do
    $verbose2 && echo "glob for partitions list directory: $glob">&2
    partListDirs=`adb_shell $sucmd echo "$glob"`
    partListDirs_len=`echo "$partListDirs" | wc -w`
    $verbose2 && echo "partitions list directory: $partListDirs">&2
    if [ $partListDirs_len -eq 1 ] && adb_return_result $sucmd test -d "$partListDirs"; then
      partListDir="$partListDirs"
      break
    fi
  done
  if [ -z "$partListDir" ]; then
    if [ $partListDirs_len -eq 1 ]; then
      echo "There are no partitions list directory for: ${partListGlobs[@]}">&2
    else
      echo "There are multiple partitions list directories for ${partListGlobs[@]} are found as follows:">&2
      echo "  $partListDirs">&2
      echo "You can use -p option to specify single partitions list directory.">&2
    fi
    return 2./
  fi
  echo "$partListDir"
}

## main
##

$testmodep || $allp || test $# -ge 1 || {
  echo "$progname: At least one argument or -a is required.">&2
  exit 1
}

nadev=`number_of_adb_devices`
if [ $nadev -eq 0 ]; then
  echo "$progname: No remote adb devices.">&2
  exit 2
elif [ $nadev -ge 2 ]; then
  echo "$progname: Two or more remote adb devices exist. Please use $ANDROID_SERIAL envvar, or -s option.">&2
  exit 2
fi

if remote_cmd_not_exist id; then
  echo "$progname: Unable to dump: No id command: I gave up.">&2
  exit 2
fi
if remote_adb_is_rooted; then
  sucmd='sh -c'
elif remote_su_not_exist; then
  echo "$progname: Unable to dump: There are neither rooted adbd nor su command on the device. Solution: TWRP recovery or root the device.">&2
  exit 2
else
  sucmd='su -c'
fi

test -f "$excludefile" && {
  exclude=`sed 's/^#.*$//;s/[:space:][:space:]*#.*$//;/^$/d' "$excludefile"`
} || exclude=''


partListDir=`get_partitions_list_dir globs`
if [ $? -ne 0 ]; then exit 2; fi


if $allp; then
  parts=`adb_shell $sucmd ls "$partListDir"`
else
  parts=''
  $testmodep && [ $# -eq 0 ] && parts="$DEFAULT_PARTITION_FOR_TESTMODE"
  for glob in "$@"; do
    partsFull=`adb_shell $sucmd ls "$partListDir/$glob"`
    parts="$parts `basename -a $partsFull`"
  done
fi
partsLen=`echo "$parts" | wc -w`


$verbose2 && echo "partitions: $parts">&2
ipart=0
for part in $parts; do
  cleanup=
  while true; do
    ipart=`expr $ipart + 1`
    $listp && {
      echo "$part"
      break
    }
    echo -n "($ipart/$partsLen)$part:"
    for ex in $exclude; do
      if [ "$part" = "$ex" ]; then
        echo " excluded."
        break 2
      fi
    done
    echo
    $testmodep && {
      cleanup="rm -rf '$tmpfile'; adb_shell '$sucmd rm -f \"$workdir/$part.img\"'"
      $dryrun || {
        trap "$cleanup" EXIT
        tmpfile=`mktemp` || {
          echo "$progname: TEST mode: $tmpfile: cannot create temporary directory.">&2; break; }
      }
      _run "adb_return_result '$sucmd \"dd if=\\\"$partListDir/$part\\\" of=\\\"$workdir/$part.img\\\" bs=1048576\"'" || {
        echo "$progname: TEST mode: remote dd for partition:$part failed. Skip it.">&2; break; }
      _run "adb_return_result '$sucmd \"chmod 644 \\\"$workdir/$part.img\\\"\"'" || {
        echo "$progname: TEST mode: chmod for file:$part.img failed. Skip partition:$part.">&2; break; }
      _run "adb pull '$workdir/$part.img' '`cygpath -w \"$tmpfile\"`' >/dev/null" || {
        echo "$progname: TEST mode: adb pull for partition:$part failed. Skip it.">&2; break; }
    }
    _run "adb_shell '$sucmd cat \"$partListDir/$part\"' >\"$part.img\""
    $testmodep && {
      if _run "cmp '$tmpfile' '$part.img'"; then
          $dryrun || echo "TEST mode: Ok (A dumped image completely same with that by dd)."
        else
          $dryrun || echo "TEST mode: Fail (A dumped image differs from that by dd). possible bug in $0."
        fi
    }
    break;
  done
  eval "$cleanup"
  trap EXIT
done
exit 0
